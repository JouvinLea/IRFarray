#! /usr/bin/env python
import numpy as np
import astropy.units as u
from astropy.units import Quantity
from astropy.io import fits
from astropy.table import Table
from astropy.coordinates import Angle
from scipy import interpolate
import math
from astropy.io.fits import Column
import sys
import os
from glob import glob
from pathlib import Path
import os
import argparse
import pylab as pt
pt.ion()

"""
Commande a lancer pour pouvoir donner des arguments au scripts
"""


# ./create_psftable.py 'Crab_4runs.list' 'ash_stereo' "Prod15_4_stereo"
#./create_psftable.py 'Crab_All.list' 'ash_stereo_thsq64' "Prod15_4_stereo"
#./create_psftable.py 'Crab_All.list' 'ash_north_stereo_thsq64' "Prod15_4_stereo"

class Observation:
    """Helper functions to compute file and folder names.
    """

    # filetypes = ['events', 'aeff', 'edisp', 'psf_3gauss']
    filetypes = ['events']

    def __init__(self, obs_id, hap_config=None, telpattern=None):
        self.obs_id = obs_id
        self.hap_config = hap_config
        self.telpattern = telpattern

    @property
    def obs_group(self):
        obs_id_min = self.obs_id - (self.obs_id % 200)
        obs_id_max = obs_id_min + 199
        return obs_id_min, obs_id_max

    @property
    def _obs_group_folder(self):
        return Path('run{:06d}-{:06d}'.format(self.obs_group[0], self.obs_group[1]))

    @property
    def _obs_folder(self):
        return Path('run{:06d}'.format(self.obs_id))

    def folder(self, step=None):
        """Create folder for a given step.
        """
        if step is None:
            return self._obs_group_folder / self._obs_folder
        else:
            return Path(step) / self._obs_group_folder / self._obs_folder

    def hap_filename(self, filetype):
        """Name of FITS file generated by HAP"""
        if filetype == 'events':
            return self.folder('events') / 'run_{:07d}_{}_eventlist.fits'.format(self.obs_id, self.hap_config)
            # return self.folder('events') / 'events_{:06d}.fits.gz'.format(self.obs_id)
        elif filetype == 'aeff':
            return self.folder('irfs') / 'aeff_{:06d}.fits.gz'.format(self.obs_id)
        elif filetype == 'edisp':
            return self.folder('irfs') / 'edisp_{:06d}.fits.gz'.format(self.obs_id)
        elif filetype == 'psf_3gauss':
            return self.folder('irfs') / 'psf_3gauss_{:06d}.fits.gz'.format(self.obs_id)
        else:
            raise ValueError('Invalid {} {}'.format(filetype))

    def out_filename(self, filetype, dir, format='old'):
        """Name of FITS file in out folder"""
        filename = self.filename(filetype=filetype, format=format)
        return Path(dir) / filename

    def filename(self, filetype, format='old'):
        if format == 'old':
            TAGS = dict(
                events='events',
                aeff='aeff_2d',
                edisp='edisp_2d',
                psf_3gauss='psf_3gauss',
                psf_king='psf_king',
                psf_table='psf_table',
                background='bkg_offruns',
            )
        elif format == 'new':
            TAGS = dict(
                events='events',
                aeff='aeff',
                edisp='edisp',
                psf_3gauss='psf_3gauss',
                psf_king='psf_king',
                psf_table='psf_table',
                background='background',
            )

        tag = TAGS[filetype]
        filename = '{}_{:06d}.fits.gz'.format(tag, self.obs_id)
        return self.folder() / filename

    def mkdir(self, step):
        """Make directory (parts=True, exists_ok=True)"""
        path = self.folder(step)
        if not path.exists():
            path.mkdir(parents=True)

        return path

    def check_out_files_exist(self):
        """Check if all out files exist"""
        for filetype in self.filetypes:
            filename = self.out_filename(filetype)
            if not filename.is_file():
                log.error('MISSING: {}'.format(filename))
                return False

        return True


def triplegauss(theta2,s1,s2,s3,A2,A3):

    s12 = s1*s1
    s22 = s2*s2
    s32 = s3*s3

    gaus1 = np.exp(-theta2/(2*s12))
    gaus2 = np.exp(-theta2/(2*s22))
    gaus3 = np.exp(-theta2/(2*s32))

    y = (gaus1 + A2*gaus2 + A3*gaus3)
    norm =  2*math.pi*(s12+ np.abs(A2) * s22 + np.abs(A3) * s32)
    return y/norm


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Make the index and obs table')
    parser.add_argument('runlist', action="store",
                        help='List of run for which we want to interpolate the IRFs')
    parser.add_argument('config', action="store", help='Prod Configuration, cut we apply')
    parser.add_argument('prod', action="store", help='Prod')
    arg = parser.parse_args()
    runlist = arg.runlist
    coupure = arg.config
    prod = arg.prod
    directory = os.path.expandvars('$CALDB')
    PathListRun = directory + "/" + prod + "/" + coupure

    # Sur Lyon
    # PathListRun = directory+"/data/hess/hap-16-03_fits/"+prod+"/"+config

    RunNumber = np.loadtxt(runlist, ndmin=2)
    # Load les info sur les MCs depuis la table d'IRF ou est stocke pour toutes les nergies, zenith,offset et efficacite des MCs la valeur des la surface efficiace, du biais et sigma pour la resolution et du s1, s2, s3, A2, A3 de la tripplegauss utilisee pour fitter la psf
    PathTableIRF = os.path.expandvars('$HESSCONFIG')
    PathTablePSF = os.path.expandvars('$HESSCONFIG')

    for nrun in RunNumber[:, 0]:
        obs = Observation(int(nrun))
        informat = "old"
        namerun = str(Path(PathListRun) / obs.filename('events', format=informat))
        try:
            table = Table.read(namerun, hdu='EVENTS')
        except Exception:
            print "fits corrupted for file " + namerun
            continue
        hdurun = fits.open(namerun)
        az=hdurun[1].data["AZ"]
        az[np.where(az>180)]=az[np.where(az>180)]-360
        AZRun=az.mean()
        AltRun = hdurun[1].data["ALT"].mean()
        if ((AZRun > 90) & (AZRun < 270)):
            mode = "south"
        else:
            mode = "north"
        ZenRun = 90 - AltRun
        EffRun = hdurun[1].header["MUONEFF"] * 100
        name_config = coupure[0:3] + "_" + mode + "_" + coupure[4:]
        #name_config="ash_north_stereo"
        print(nrun)
        print(PathTableIRF + "/" + name_config + "/IRF_" + name_config + ".npz")
        IRF = np.load(PathTableIRF + "/" + name_config + "/IRF_" + name_config + ".npz")
        IRFArea = IRF["TableArea"]
        IRFSigma = IRF["TableSigma"]
        IRFBiais = IRF["TableBiais"]
        enMC = IRF["enMC"]
        lnenMC = IRF["lnenMC"]
        zenMC = IRF["zenMC"]
        effMC = IRF["effMC"]
        offMC = IRF["offMC"]

        PSF = np.load(PathTablePSF + "/" + name_config + "/PSF_triplegauss_" + name_config + ".npz")
        PSFs1 = Angle(PSF["TableSigma1"],"deg")
        PSFs2 = Angle(PSF["TableSigma2"],"deg")
        PSFs3 = Angle(PSF["TableSigma3"],"deg")
        PSFA2 = PSF["TableA2"]
        PSFA3 = PSF["TableA3"]

        binoffMC = len(offMC)
        binEMC = len(enMC)
        binzenMC = len(zenMC)
        bineffMC = len(effMC)
        
        # reverifier qu ils ont bien ca dans leur bin PA en low edge et upper edge
        off_low = offMC
        off_hi = offMC

        # pour les extremites prendre le milieu des bin en log
        binlnEMC = lnenMC[1:] - lnenMC[:-1]
        # Pour le premier bin en energie pour defenr le edge low du bin on prend la demilargeur du premier bin
        binlnEMClow = np.insert(binlnEMC, 0, binlnEMC[0])
        # Pour le dernier bin en energie pour defenr le edge up du bin on prend la demilargeur du dernier bin
        binlnEMCup = np.insert(binlnEMC, -1, binlnEMC[-1])
        # Retrouver
        lnEMClow = lnenMC - binlnEMClow / 2
        lnEMCup = lnenMC + binlnEMCup / 2
        E_true_low = pow(10, lnEMClow)
        E_true_up = pow(10, lnEMCup)

        rad = Angle(np.arange(0, 1.5, 0.005), 'deg')
        rad_low=rad[0:-1]
        rad_high=rad[1:]
        rad_mean=(rad_low+rad_high)/2.
        bin_rad=len(rad_mean)
        len_psf_table = bin_rad*binoffMC*binEMC
        
        
        hist_value=Quantity(np.zeros(PSFA3.shape),"sr^-1")
        hist_value2=Quantity(np.zeros((bin_rad,binEMC,binoffMC,binzenMC,bineffMC)),"sr^-1")
        PSF_table=np.zeros((bin_rad,binoffMC, binEMC))
        PSF_table2=np.zeros((bin_rad,binoffMC, binEMC))

        s1_mesh=np.tile(PSFs1, (len(rad_mean.value),1,1,1,1))
        s2_mesh=np.tile(PSFs2, (len(rad_mean.value),1,1,1,1))
        s3_mesh=np.tile(PSFs3, (len(rad_mean.value),1,1,1,1))
        A2_mesh=np.tile(PSFA2, (len(rad_mean.value),1,1,1,1))
        A3_mesh=np.tile(PSFA3, (len(rad_mean.value),1,1,1,1))
        rad_mesh=rad_mean.reshape(len(rad_mean.value),1,1,1,1) * np.ones_like(PSFs1.value)
        hist_value2=triplegauss(rad_mesh**2,s1_mesh,s2_mesh,s3_mesh,A2_mesh,A3_mesh).to("sr^-1")
        for (iEMC, EMC) in enumerate(enMC):
            for (ioff, off) in enumerate(offMC):
                ind_zen, ind_eff = np.where(PSFs1[iEMC, ioff, :, :].value != -1)
                        # If there is at least one simu for this offset and this energy for wich the fit works
                if (len(ind_zen) != 0):
                    zensame = np.where(ind_zen != ind_zen[0])
                    effsame = np.where(ind_eff != ind_eff[0])
                    # Il doit y avoir au moins 2 valeurs differentes en efficacite et en zenith pour que l interpolateur marche
                    if ((len(zensame[0]) != 0) & (len(effsame[0]) != 0)):
                        coord_eff = effMC[ind_eff]
                        coord_zen = zenMC[ind_zen]
                        points = (coord_eff, np.cos(coord_zen * math.pi / 180))
                        #points = (np.cos(coord_zen * math.pi / 180),coord_eff)
                        #import IPython; IPython.embed()
                        #hist_value[iEMC, ioff, ind_zen, ind_eff]=triplegauss((rad_mean[irad]**2), PSFs1[iEMC, ioff, ind_zen, ind_eff] , PSFs2[iEMC, ioff, ind_zen, ind_eff], PSFs3[iEMC, ioff, ind_zen, ind_eff] , PSFA2[iEMC, ioff, ind_zen, ind_eff] ,PSFA3[iEMC, ioff, ind_zen, ind_eff])
                        
                        #PSF_table[irad,ioff, iEMC]=interpolate.griddata(points, hist_value[iEMC, ioff, ind_zen, ind_eff].value,
                        #                                            (EffRun, np.cos(ZenRun * math.pi / 180)),
                        #                                            method='linear')
                        for (irad,rad) in enumerate(rad_mean):    
                            PSF_table[irad,ioff, iEMC]=interpolate.griddata(points, hist_value2[irad,iEMC, ioff, ind_zen, ind_eff].value,
                                                                (EffRun, np.cos(ZenRun * math.pi / 180)),
                                                                method='linear')
                            if np.isnan(PSF_table[ irad,ioff, iEMC]):
                                PSF_table[irad,ioff, iEMC]=interpolate.griddata(points, hist_value2[irad,iEMC, ioff, ind_zen, ind_eff].value, (EffRun, np.cos(ZenRun * math.pi / 180)), method='nearest')
            #if((ioff==1) & (iEMC==10)):
                #    import IPython; IPython.embed()
        #outdir = str(Path("/Users/jouvin/Desktop/these/FITS_DATA/HAP-FR/Prod15_4_stereo/test_ash_stereo_thsq64_psftable") / obs.folder())
        outdir = str(Path(PathListRun) / obs.folder())
        # PSF FITS FILE
        c1_psf = Column(name='ENERG_LO', format=str(binEMC) + 'E', unit='TeV', array=np.atleast_2d(E_true_low))
        c2_psf = Column(name='ENERG_HI', format=str(binEMC) + 'E', unit='TeV', array=np.atleast_2d(E_true_up))
        c3_psf = Column(name='THETA_LO', format=str(binoffMC) + 'E', unit='deg', array=np.atleast_2d(off_low))
        c4_psf = Column(name='THETA_HI', format=str(binoffMC) + 'E', unit='deg', array=np.atleast_2d(off_hi))
        c5_psf = Column(name='RAD_LO', format=str(bin_rad) + 'E', unit='deg', array=np.atleast_2d(rad_low))
        c6_psf = Column(name='RAD_HI', format=str(bin_rad) + 'E', unit='deg', array=np.atleast_2d(rad_high))
        c7_psf = Column(name='RPSF', format=str(len_psf_table) + 'E', unit='sr^-1', array=np.expand_dims((PSF_table),0))

        
        tbhdu_psf = fits.BinTableHDU.from_columns(
            [c1_psf, c2_psf, c3_psf, c4_psf, c5_psf, c6_psf, c7_psf])
        tbhdu_psf.header.set("EXTNAME", "PSF_2D_TABLE", "name of this binary table extension")
        #tbhdu_psf.header.set("TDIM7", "(" + str(binEMC) + "," + str(binoffMC) + "," + str(bin_rad) + ")")
        tbhdu_psf.header.set("TDIM7", "(" + str(binEMC) + "," + str(binoffMC) + "," + str(bin_rad) + ")")
        tbhdu_psf.writeto(outdir + '/psf_table_{:06d}.fits'.format(int(nrun)), clobber=True)
        #tbhdu_psf.writeto(outdir + '/psf_3gauss_0' + str(int(nrun)) + '.fits', clobber=True)
        if Path(outdir + '/psf_3gauss_{:06d}.fits'.format(int(nrun))).exists():
            os.remove(outdir + '/psf_3gauss_{:06d}.fits'.format(int(nrun)))
        

